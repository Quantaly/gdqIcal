package lib

import (
	"fmt"
	"golang.org/x/net/html"
	"io"
	"log"
	"net/http"
)

// GenerateCalendar generates the iCalendar file into w
func GenerateCalendar(w io.Writer, scheduleURL string) {
	fmt.Fprintf(w, "BEGIN:VCALENDAR\r\n")
	fmt.Fprintf(w, "PRODID:-//Kai Page//github.com/Quantaly/gdqIcal//EN\r\n")
	fmt.Fprintf(w, "VERSION:2.0\r\n")
	defer fmt.Fprintf(w, "END:VCALENDAR\r\n")

	resp, err := http.Get(scheduleURL)
	if err != nil {
		log.Println("GenerateCalendar:", err)
		return
	}

	z := html.NewTokenizer(resp.Body)

	// find h1
	for {
		tt := z.Next()
		if tt == html.ErrorToken {
			log.Println("GenerateCalendar: h1 not found")
			return
		}
		tagName, _ := z.TagName()
		if tt == html.StartTagToken && string(tagName) == "h1" {
			z.Next() // text: schedule name
			fmt.Fprintf(w, "X-WR-CALNAME:%s\r\n", string(z.Text()))
			break
		}
	}

	fmt.Fprintf(w, "X-WR-CALDESC:Autogenerated from %s\r\n", scheduleURL)

	// find tbody
	for {
		tt := z.Next()
		if tt == html.ErrorToken {
			log.Println("GenerateCalendar: tbody not found")
			return
		}
		tagName, _ := z.TagName()
		if tt == html.StartTagToken && string(tagName) == "tbody" {
			break
		}
	}

	z.Next() // text: newline

	// parse games
	for {
		tt := z.Next() // <tr> or </tbody>
		if tt == html.ErrorToken {
			log.Println("GenerateCalendar: end of tbody not found")
			return
		}
		tagName, _ := z.TagName()
		if tt == html.EndTagToken && string(tagName) == "tbody" {
			break
		}

		game, err := ParseGame(z)
		if err != nil {
			log.Println("GenerateCalendar:", err)
			return
		}
		game.WriteIcalEvent(w)
	}
}
